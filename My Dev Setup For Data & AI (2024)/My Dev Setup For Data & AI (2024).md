# My Dev Setup For Data & AI (2024)

TODO: add images

## Purpose
- To share my current developer setup with others
- Make my life easier when I need to setup a new machine
- Make others' lives easier by providing all steps
- This is a basic setup to learn about `Data` (`Engineering`, `Analysis`, `Science`), `Artificial Intelligence`, `Computer Science`, `Software Engineering`, etc.
- I think this gives a pretty nice overview of a possible local dev setup, and how different tools work together, with an engineering perspective
- Of course this can be automated in the future, with Shell scripting, devcontainer (Docker), etc. But honestly I'm still exploring a bunch of different tech stacks
- Depending on your needs, just install what you need from here, and complete it with additional things you might need, in any case, this should cover the basics for automation (`Python`), database interaction (`PostgreSQL`), containerization (`Docker`) which enable you to install pretty much everything (the `Mage` orchestrator, etc.)
- I've used this setup to finish the `Data Engineering Zoomcamp` free course by `DataTalksClub`
- I will be using this same setup to go through the `LLM Zoomcamp` free course by `DataTalksClub`
- This file will be dynamic, as my current needs change 

## Summary
- **Main Operating System (OS):** Windows 11 (applicable to Windows 10)
- **Secondary OS:** Linux Ubuntu via Windows Subsystem for Linux (WSL)
- **Terminals:** BASH (with custom prompt for Git branches) + ZSH (OhMyZsh)
- **IDE:** Visual Studio Code (VS Code) (installed on Windows)
- **Version Control System:** Git + GitHub (with automated SSH-agent and passphrases)
- **Python Environment Manager:** Miniconda
- **Containerization:** Docker Desktop (installed on Windows)
- **Database:** PostgreSQL + pgcli + pgAdmin


## Setup Windows Subsystem for Linux (WSL)

### Useful references
https://learn.microsoft.com/en-us/windows/wsl/install-manual
https://learn.microsoft.com/en-us/windows/terminal/install

### Operating system
Windows 11 or Windows 10

![Windows 11 or Windows 10](./assets/win10-win11-logos.png)


### Hardware virtualization
Enabled (check on Task Manager -> Performance -> Virtualization: Enabled)
If it's not, I suggest enabling it on BIOS (on your CPU options enable Intel VT-x or AMD-V)
(not sure if this is mandatory, but I always do this to ensure I can create virtual machines
it might have some performance impact on your WSL2 setup, just in case, enable it if you can)

### Turn Windows features on or off
Enable both:
- Virtual Machine Platform
- Windows Subsystem for Linux

### Restart machine

### Install / Update WSL
Using Command Prompt (CMD) run several times
```bash
wsl --update
```
until the last version is installed

### Check available Linux distros
```bash
wsl --list --online
```

### Choose and install Linux distro
```bash
wsl --install -d Ubuntu-22.04
```

### Define UNIX username

### Define password

### Install terminal
From Microsoft Store install the official Terminal app by Microsoft Corporation, if you don't have it yet

### Default terminal
Make Linux distro the default terminal on Terminal app

### Upgrade and Update Linux distro
```bash
sudo apt update
sudo apt upgrade
```

## Review Linux Commands
Basic Linux Commands for Beginners


## Setup Git and GitHub with SSH

### Useful references
https://docs.github.com/en/authentication/connecting-to-github-with-ssh

### Install Git
Git should be installed by default, run the following to check
```bash
git
```
If not installed
```bash
sudo apt install git
```

### Generate SSH key
- Use same email as GitHub account
- Replace the following command with your email and run it
```bash
ssh-keygen -t ed25519 -C "techwithcosta@gmail.com"
```
- Empty filename, just press `ENTER`
- Add a passphrase easy to remember, you will type it often
- The `~/.ssh` folder is created
- Run the following to see it
```bash
la ~/.ssh
```

### Create GitHub account if you don't have one yet

### Add the public SSH key to GitHub account
- Check the contents of the public key generated by the last step
- Make sure it's the file with the `.pub` extension
```bash
cat ~/.ssh/id_ed25519.pub
```
- Copy the whole file content
- Go to GitHub account, "Settings" -> "SSH and GPG keys" -> "New SSH key"
- **Title =** wsl
- **Key type =** Authentication Key
- **Key =** paste what you've copied from the last step
- "Add SSH key"
- Enter your GitHub password if prompted
- The public SSH key has been added

### Test SSH connection to GitHub
Run the following
```bash
ssh -T git@github.com
```
- You will see a key fingerprint
- Before moving forward, copy it
- Go to https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/githubs-ssh-key-fingerprints
- Confirm if it matches the respective encryption algorithm (e.g. Ed25519)
- For example:
```bash
SHA256:+DiY3wvvV6TuJJhbpZisF/zLDA0zPMSvHdkr4UvCOqU
```
- If it matches, type `yes` and hit `ENTER` to move forward
- Enter your passphrase
- You should have been successfully authenticated


### Confirm keys from known hosts
- Two files have been created inside `~/.ssh` folder `known_hosts` and `known_hosts.old`
- Run the following to check the contents of `known_hosts`
```bash
cat ~/.ssh/known_hosts
```
- Go to https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/githubs-ssh-key-fingerprints
- Confirm if all fingerprints (should be 3) from the file match the ones from the website
- For example 1st:
```bash
ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIOMqqnkVzrm0SdG6UOoqKLsabgH5C9okWi0dh2l9GKJl
```
- For example 2nd:
```bash
ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQCj7ndNxQowgcQnjshcLrqPEiiphnt+VTTvDP6mHBL9j1aNUkY4Ue1gvwnGLVlOhGeYrnZaMgRK6+PKCUXaDbC7qtbW8gIkhL7aGCsOr/C56SJMy/BCZfxd1nWzAOxSDPgVsmerOBYfNqltV9/hWCqBywINIR+5dIg6JTJ72pcEpEjcYgXkE2YEFXV1JHnsKgbLWNlhScqb2UmyRkQyytRLtL+38TGxkxCflmO+5Z8CSSNY7GidjMIZ7Q4zMjA2n1nGrlTDkzwDCsw+wqFPGQA179cnfGWOWRVruj16z6XyvxvjJwbz0wQZ75XK5tKSb7FNyeIEs4TT4jk+S4dhPeAUC5y+bDYirYgM4GC7uEnztnZyaVWQ7B381AK4Qdrwt51ZqExKbQpTUNn+EjqoTwvqNj4kqx5QUCI0ThS/YkOxJCXmPUWZbhjpCg56i+2aB6CmK2JGhn57K5mj0MNdBXA4/WnwH6XoPWJzK5Nyu2zB3nAZp+S5hpQs+p1vN1/wsjk=
```
- For example 3rd:
```bash
ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBEmKSENjQEezOmxkZMy7opKgwFB9nkt5YRrYMjNuG5N87uRgg6CLrbo5wAdT/y6v0mKV0U2w0WZ2YB/++Tpockg=
```
- If everything matches perfectly, move forward

### Remove old known hosts file
```bash
rm ~/.ssh/known_hosts.old
```

### Configure Git with your identity
- Run the following to specify who is going to sign your commits with a user name and email
- I use my first and surnames and the same email address as the GitHub account
- Replace with yours
```bash
git config --global user.name "Diogo Costa"
git config --global user.email techwithcosta@gmail.com
```
- The `~/.gitconfig` is created
- Run the following to confirm your identity has been added
```bash
cat ~/.gitconfig
```

### Create folder for projects on user's home directory "git"
- This folder will contain all your projects, name it `git`, `projects`, `code` or whatever
- I call mine `git`
```bash
mkdir ~/git
```

### Clone original course repo
- From this point forward, the process applies to pretty much any coding project you might be following, or creating yourself
- I will exemplify it using the new `LLM Zoomcamp` free course by `DataTalksClub`
- Run something similar to the following to clone the original course repository into the `git` folder
- If your folder has a different name, replace it
```bash
cd ~/git
git clone git@github.com:DataTalksClub/llm-zoomcamp.git
```
- Enter your passphrase (we will automate this further ahead)
- I do this to have easy local access to the course materials
- I just run the following each time I start working, to ensure my local branch is up to date
```bash
cd ~/git/llm-zoomcamp
git fetch
git pull
```

### Create and clone your course repo
- Go to your GitHub account
- `Repositories` -> `New`
- **Repository name =** *llm-zoomcamp-2024* **(or other)**
- **Description =** *Course walkthrough: Large Language Models Zoomcamp 2024 (by DataTalksClub).* **(or other)**
- **Public**, to share the repo with everyone, course community, for homework submission and portfolio
- **Initialize this repository with: =** Enable *Add a README file*
- `Create repository`
- Clone the repository by running something similar to the following, replace with yours
```bash
cd ~/git
git clone git@github.com:techwithcosta/llm-zoomcamp-2024.git
```
- Enter your passphrase (we will automate this further ahead)

## Setup Linux Terminals

### Backup `.bashrc` file
```bash
cp ~/.bashrc ~/.bashrc.bak
```

### Customize BASH prompt for Git
- Let's customize the BASH prompt to include the git branch name on it each time we are in a `.git` folder
- Run the following to edit the file
```bash
nano ~/.bashrc
```
- Use the `DOWN ARROW` or `PAGE DOWN` to find the following rows
```bash
if [ "$color_prompt" = yes ]; then
    PS1='${debian_chroot:+($debian_chroot)}\[\033[01;32m\]\u@\h\[\033[00m\]:\[\033[01;34m\]\w\[\033[00m\]\$ '
else
    PS1='${debian_chroot:+($debian_chroot)}\u@\h:\w\$ '
fi
```
- Delete them by pressing `CTRL + K` after positioning the cursor on each of them, using the keyboard arrows
- **NOTE:** Do not delete the following row
```bash
unset color_prompt force_color_prompt
```
- Add the following rows to replace them
```bash
# Add git branch to prompt
parse_git_branch() {
    git rev-parse --is-inside-work-tree >/dev/null 2>&1 || return
    git branch 2> /dev/null | sed -e '/^[^*]/d' -e 's/* \(.*\)/(\1)/' | sed 's/^/ /'
}
if [ "$color_prompt" = yes ]; then
 PS1='${debian_chroot:+($debian_chroot)}\[\033[01;32m\]\u@\h\[\033[00m\]:\[\033[01;34m\]\w\[\033[01;31m\]$(parse_git_branch)\[\033[00m\]\$ '
else
 PS1='${debian_chroot:+($debian_chroot)}\u@\h:\w$(parse_git_branch)\$ '
fi
```
- Save the file by pressing `CTRL + X`, then hit `Y` and then `ENTER`
- The `PS1` variable defines what appears in the terminal prompt, using ANSI codes for colors, etc.
- We use the function `parse_git_branch` and a regular expression to get the activated branch whenever we are in a `.git` folder
- Concatenation is used to include the branch name into the prompt
- This is super useful for Git + GitHub workflows, if you prefer BASH
- I mostly use ZSH, which has a lot of customization frameworks with themes, colors, extra functionalities, such as `OhMyZsh`, `OhMyPosh`, `Powerlevel10k`, `Starship`, etc.

### Refresh BASH
Open a new BASH window for the changes to take effect

### Check Git branch name on BASH prompt
To validate this, go to a git repository such as
```bash
cd ~/git/llm-zoomcamp
```
Verify that the selected branch appears in the prompt automatically, most likely the `main` branch

### Delete `.bashrc` backup
If everything went well, delete the backup file (or not)
```bash
rm ~/.bashrc.bak
```

### Install zsh
```bash
sudo apt install zsh
```

### Install OhMyZsh
```bash
sh -c "$(wget -O- https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)"
```
I like to have ZSH as my default shell, so I choose `Y` when prompted

### Automate SSH-Agent passphrases for both BASH and ZSH

- Append the following code to the bottom of both `.bashrc` and `.zshrc` files
- This way you only have to enter your passphrase once, per terminal, per computer start up
```bash
# Auto-lauching ssh-agent
env=~/.ssh/agent.env

agent_load_env () { test -f "$env" && . "$env" >| /dev/null ; }

agent_start () {
    (umask 077; ssh-agent >| "$env")
    . "$env" >| /dev/null ; }

agent_load_env

# agent_run_state: 0=agent running w/ key; 1=agent w/o key; 2=agent not running
agent_run_state=$(ssh-add -l >| /dev/null 2>&1; echo $?)

if [ ! "$SSH_AUTH_SOCK" ] || [ $agent_run_state = 2 ]; then
    agent_start
    ssh-add
elif [ "$SSH_AUTH_SOCK" ] && [ $agent_run_state = 1 ]; then
    ssh-add
fi

unset env
```
Use the following commands
```bash
nano ~/.bashrc
```
```bash
nano ~/.zshrc
```
- Open multiple BASH and ZSH windows to validate
- Test SSH connection to GitHub
```bash
ssh -T git@github.com
```

## Setup VS Code With WSL (IDE)

### Download Visual Studio Code (VS Code)
https://code.visualstudio.com/download

### Install VS Code
- Activate all ticks except desktop icon
- Pin to taskbar

### Follow the welcome steps if you want and read docs to learn more about VS Code functionalities
https://code.visualstudio.com/docs
https://code.visualstudio.com/docs/remote/wsl
https://code.visualstudio.com/docs/terminal/basics
https://code.visualstudio.com/docs/python/python-quick-start
https://code.visualstudio.com/docs/containers/overview
Explore WSL, Git + GitHub setup, Python, Docker etc.

### Install WSL extension
- It should pop up automatically
- If not, go to extensions panel and find it: `WSL` by Microsoft

### Open VS Code from WSL
- Close VS Code
- Go to a project folder on Linux terminal
- Execute the following from that folder
```bash
code .
```
- Or
```bash
code ~/git/llm-zoomcamp
```
- A remote connection to Linux distribution will be created after the automatic setup of VS Code Server
- This means we will be working on Linux Ubuntu, with VS Code installed on Windows, in a seamless way, leveraging both OSs
- Trust the authors

### Check `WSL` tab
- On bottom left corner, find the WSL tab, left click to see several options
- Since we've launched WSL directly from the folder on Ubuntu, the remote connection is established automatically
- We don't need to do anything else here
- Close the welcome page

### Time to explore VS Code (optional)
### Check `Explorer` panel
Here you can find all files and folders that exist within the directory you are currently working at

### Open a file
- Open the `README.md`, one click opens a temporary tab, two clicks opens a fixed tab
- Press `CTRL + SHIFT + P`, select `Markdown: Open Preview to the Size`
- You can achieve the same thing with `CTRL + K` (notice the message in the bottom tab) and then `V`
- Now you see the markdown code on the left, and the rendered result on the right, the scroll is synchronized

### Check `Search` panel
Enables you to search through all folders and files, even with regular expressions

### Check `Run and Debug` panel
Super useful functionality, to debug any type of code in an interactive way

### Check `Extensions` panel
- Install `Code Spell Checker` by Street Side Software, for spelling suggestions, right click -> "Spelling Suggestions..."
- Install `Todo Tree` by Gruntfuggly, write "TODO" as a coding language comment to group all your TODOs in the `TODOs` panel
- There are a ton of extensions to explore, for pretty much everything you can imagine

### Check `Remote Explorer` panel
- Shows the WSL targets, in this case Ubuntu, where we are connected to

### Open new terminal
- `Terminal` -> `New Terminal`
- Or with shortcut, on my Portuguese keyboard is `CTRL + SHIFT + ç` (cedilla)
- `CTRL + ç` closes and opens the current terminal
- All shortcuts are customizable on `File` -> `Preferences` -> `Keyboard Shortcuts`
- By default ZSH opens
- Can open multiple terminals, BASH, etc.
- Even multiplexers such as Tmux, to split one terminal windows into many more
- This provides direct interaction with the WSL distribution directly from within VS Code

### Check `Git + GitHub` tab
- On bottom left corner, we have direct access to branches options
- We can create and switch between branches, and the repository updates automatically in the Explorer panel
- Search for Git on `CTRL + SHIFT + P` to see options
- You can choose to interact with Git via UI, or via integrated terminals in the bottom

### Check `Source Control` panel
- For this, switch to my course repository
```bash
code ~/git/llm-zoomcamp-2024 
```
- Since the current work folder is also a Git repository, the Source Control panel will show file changes and enable you to add, commit and push changes directly to the remote repository
- It even shows the differences for edited files
- Open a ZSH within VS Code with `CTRL + ç`
- Edit the `README.md` file
- Notice the white circle on the tab name, showing that the file has been edited but not saved
- Save the file with `CTRL + S`
- Notice the yellow names on tab and `Explorer` panel, and the `M` in front of the filename, standing for `Modified`
- Open `Source Control` panel see that `README.md` file has been changed
- Click on it
- Green shows a new added line, red would be removed, etc.
- Click on `+` to stage changes
- Write a commit message
- `Commit`
- `Sync Changes` to push to remote repository, `OK`
- Check repo on GitHub to see change
- `Would you like Visual Studio Code to periodically run "git fetch"?`No, I like to pull the code manually
- Can do this via terminal `git pull` or on bottom left corner with "cycle" symbol
- Edit `README.md` file again, refresh terminal, check cross on OhMyZsh prompt, indicating there are changes

## Setup VS Code For Python on WSL With Miniconda
https://engineeringfordatascience.com/posts/install_miniconda_from_the_command_line/

### Install latest version of Miniconda
- Run the following to install Miniconda
```bash
mkdir -p ~/miniconda3
wget https://repo.anaconda.com/miniconda/Miniconda3-latest-Linux-x86_64.sh -O ~/miniconda3/miniconda.sh
bash ~/miniconda3/miniconda.sh -b -u -p ~/miniconda3
rm -rf ~/miniconda3/miniconda.sh
~/miniconda3/bin/conda init bash
~/miniconda3/bin/conda init zsh
```
- Refresh terminal
- It will be stored on the `~/miniconda3` folder, containing the `envs` we create in the future

### Default env activation
- `(base)` appears now behind the prompt, indicating that the "base" conda env is activated
- I don't like this, so to prevent conda from activating the base env by default run the following
```bash
conda config --set auto_activate_base false
```
- Refresh the terminal, it does not activate anymore

### Create conda environment
- Create conda env for project named `llm-zoomcamp-2024-env`
```bash
conda create -n llm-zoomcamp-2024-env python=3.10
```
- I like to use the project folder name + `-env`
- Change the Python version if needed
- If you omit "python=3.10", a new env will be created but without Python and you would need to install it manually

### Conda environments interaction
You can activate specific environments with
```bash
conda activate llm-zoomcamp-2024-env
```
Deactivate the current env
```bash
conda deactivate
```
List envs (if one is activated, will show asterisk on it)
```bash
conda env list
```

### Open project on VS Code
Open VS Code from project folder by running
```bash
code ~/git/llm-zoomcamp-2024
```

### Create and save Python file
```bash
code main.py
```

### Install extension
`Python` by Microsoft

### Associate correct Python interpreter on VS Code
- Click the Python interpreter tab on bottom right corner or `CTRL + SHIFT + P` and search for "Python: Select Interpreter"
- Choose the env you've just created
- Refresh terminals inside VS Code
- From now on whenever you open the project with VS Code, this conda env will be activated in the terminal, and the interpreter correctly selected
- Whenever we install packages via the terminal, ensuring the correct env is activated, the packages will be isolated into it, avoiding corruption of other projects
- Restart VS Code and validate activated env + selected interpreter
- You might need to do this a couple of times to save the setup

### Python manager workflow
- For each project I have within the `git` folder that require Python, I create a specific conda env for each one, to ensure package isolation
- Then I associate each VS Code instance to each project / conda env / interpreter

### Python examples
- script.py with print('hello world'), execute using UI play and terminal

### Additional extension
`Jupyter` by Microsoft

### Python examples
- cells.py with #%%, execute cell using UI, CTRL + ENTER or SHIFT + ENTER, install ipykernel package, show interactive window, jupyter tab
- save the file as cells.ipynb to see it as a classic jupyter notebook, to run it select an interpreter

### Python example (Jupyter notebook browser)
If you really want to run a jupyter notebook on browser
```bash
pip install jupyter
jupyter notebook
```
Jupyter server will start and ports will be forwarded. Then open the browser. Copy token from
```bash
jupyter server list
```
Paste token on browser, set up a new password, login, open the notebook from the file explorer.

### GIt example
Commit Python file.

## Download and install Docker Desktop on Windows

Run the following and confirm that Docker is not accessible
```bash
docker
```

https://www.docker.com/products/docker-desktop/

- Use WSL2 instead of Hyper-V during setup
- Run docker after installation
- Sign up and / or sign in
- Check for updates
- Update and restart PC
- Start Docker engine

https://docs.docker.com/desktop/wsl/

- Go to Settings -> General and check if "Use the WSL 2 based engine" is ticked
- Go to Settings -> Resources -> WSL Integration: check if "Enable integration with my default WSL distro" is ticked and enable your distro "Ubuntu-22.04"
- Apply & restart

Now the following command should output something
```bash
docker
```

Run your first container
```bash
docker run -d -p 8080:80 docker/welcome-to-docker
```

Open browser and go to http://localhost:8080/

If you get this error
```bash
docker: Error response from daemon: Head "https://registry-1.docker.io/v2/docker/welcome-to-docker/manifests/latest": unauthorized: incorrect username or password.
```

Log out from Docker using the system tray icon. Then login via terminal
```bash
docker login --username techwithcosta
```
Enter password

Run your first container
```bash
docker run -d -p 8080:80 docker/welcome-to-docker
```

Open browser and go to http://localhost:8080/

## Setup Docker with PostgreSQL (database)

### Define containers

Create **docker-compose.yaml** file

```yaml
services:
  pgdatabase:
    image: postgres:13
    environment:
      - POSTGRES_USER=root
      - POSTGRES_PASSWORD=root
      - POSTGRES_DB=ny_taxi
    volumes:
      - "./ny_taxi_postgres_data:/var/lib/postgresql/data"
    ports:
      - "5432:5432"
  pgadmin:
    image: dpage/pgadmin4
    environment:
      - PGADMIN_DEFAULT_EMAIL=admin@admin.com
      - PGADMIN_DEFAULT_PASSWORD=root
      - POSTGRES_DB=ny_taxi
    volumes:
      - pgadmin_data:/var/lib/pgadmin/data
    ports:
      - "8080:80"
volumes:
  pgadmin_data:
```
Stop all containers to ensure all ports are available.

```bash
docker compose up
```

### Setup pgcli

Install pgcli dependencies
https://www.pgcli.com/install

```bash
sudo apt-get install libpq-dev
```

Install pgcli with correct env activated (it's a Python package)
```bash
pip install pgcli
```

### Connect to PostgreSQL via pgcli

Access the PostgreSQL DB on Docker container, use the credentials from docker file -h host, -p port, -u user, -d db name
```bash
pgcli -h localhost -p 5432 -u root -d ny_taxi
```
Enter password

Check empty list of tables inside DB
```bash
\dt
```
Quit by pressing `q`

### Connect to PostgreSQL via pgAdmin

Both containers have to be connected to the same network in order to pdAdmin connect to PostgreSQL DB.

Go to browser and http://localhost:8080/. pgAdmin should open. Login using credentials on docker file.

On pdAdmin go to Object -> Register -> Server. Give it a name "mydb", go to Connection "Host name/address" should be "pgdatabase" or "host.docker.internal". Port is 5432, Username "root", Password "root".

**1. Using pgdatabase as Hostname**
When you use pgdatabase as the hostname, it works because Docker Compose creates a default network for the services defined in the same docker-compose.yml file. Containers in the same Docker Compose project can communicate with each other using their service names as hostnames. This means pgadmin can reach pgdatabase by resolving pgdatabase to the correct IP address of the PostgreSQL container.

**2. Using host.docker.internal as Hostname**
When you use host.docker.internal as the hostname, it works because host.docker.internal is a special DNS name that resolves to the internal IP address of the host machine. This allows containers to access services running on the host machine. Since you mapped port 5432 on the host to port 5432 on the pgdatabase container, pgAdmin can connect to PostgreSQL using the host's IP address.

https://stackoverflow.com/questions/25540711/docker-postgres-pgadmin-local-connection

### Create sample table via pgAdmin

Create sample table with new query: https://www.w3schools.com/postgresql/postgresql_create_table.php

```sql
CREATE TABLE cars (
  brand VARCHAR(255),
  model VARCHAR(255),
  year INT
);
```

Insert some data

```sql
INSERT INTO cars (brand, model, year)
VALUES
  ('Volvo', 'p1800', 1968),
  ('BMW', 'M1', 1978),
  ('Toyota', 'Celica', 1975);
```

View all rows on pgAdmin.

### Access same table via pgcli

On pgcli run \dt see new table.
```sql
SELECT * FROM cars;
SELECT * FROM cars ORDER BY year;
SELECT * FROM cars WHERE year >= 1975;
```


## Install Terraform Infrastructure as Code (IaC)

Follow steps from: https://developer.hashicorp.com/terraform/tutorials/aws-get-started/install-cli

Ensure that your system is up to date and you have installed the `gnupg`, `software-properties-common`, and `curl` packages installed. You will use these packages to verify HashiCorp's GPG signature and install HashiCorp's Debian package repository.
```bash
sudo apt-get update && sudo apt-get install -y gnupg software-properties-common
```

Install the HashiCorp GPG key.
```bash
wget -O- https://apt.releases.hashicorp.com/gpg | \
gpg --dearmor | \
sudo tee /usr/share/keyrings/hashicorp-archive-keyring.gpg > /dev/null
```

Verify the key's fingerprint.
```bash
gpg --no-default-keyring \
--keyring /usr/share/keyrings/hashicorp-archive-keyring.gpg \
--fingerprint
```

The gpg command will report the key fingerprint. Linux package checksum verification here, confirm fingerprint
https://www.hashicorp.com/trust/security?product_intent=terraform

Add the official HashiCorp repository to your system. The `lsb_release -cs` command finds the distribution release codename for your current system, such as `buster`, `groovy`, or `sid`.
```bash
echo "deb [signed-by=/usr/share/keyrings/hashicorp-archive-keyring.gpg] \
https://apt.releases.hashicorp.com $(lsb_release -cs) main" | \
sudo tee /etc/apt/sources.list.d/hashicorp.list
```

Download the package information from HashiCorp.
```bash
sudo apt update
```

Install Terraform from the new repository.
```bash
sudo apt-get install terraform
```

Verify installation.
```bash
terraform
```

Install the autocomplete package.
```bash
terraform -install-autocomplete
```

Create a directory named `learn-terraform-docker-container`.
```bash
mkdir learn-terraform-docker-container
```

This working directory houses the configuration files that you write to describe the infrastructure you want Terraform to create and manage. When you initialize and apply the configuration here, Terraform uses this directory to store required plugins, modules (pre-written configurations), and information about the real infrastructure it created.

Navigate into the working directory.

```bash
cd learn-terraform-docker-container
```

In the working directory, create a file called `main.tf` and paste the following Terraform configuration into it.

```bash
code main.tf
```
Paste following code.

```terraform
terraform {
  required_providers {
    docker = {
      source  = "kreuzwerker/docker"
      version = "~> 3.0.1"
    }
  }
}

provider "docker" {}

resource "docker_image" "nginx" {
  name         = "nginx"
  keep_locally = false
}

resource "docker_container" "nginx" {
  image = docker_image.nginx.image_id
  name  = "tutorial"

  ports {
    internal = 80
    external = 8000
  }
}
```

Install extension on VS Code: `HashiCorp Terraform` by HashiCorp. Now the file gets highlighted.

Initialize the project, which downloads a plugin called a provider that lets Terraform interact with Docker.

If you get errors such as `Error: Failed to query available provider packages` you have permissions / connection problems with your WSL / Ubuntu. Workaround here https://github.com/microsoft/WSL/issues/8022

If you have to restore the `/etc/resolv.conf` file:
```bash
sudo apt-get install --reinstall resolvconf
```

```bash
terraform init
```

Provision the NGINX server container with `apply`. When Terraform asks you to confirm type `yes` and press `ENTER`.
```bash
terraform apply
```

Verify the existence of the NGINX container by visiting localhost:8000 in your web browser or running `docker ps` to see the container.
```bash
docker ps
```

To stop the container, run `terraform destroy`.
```bash
terraform destroy
```

essentially, before starting the course, a beginner should understand the following (this course is not beginner friendly)
- IT (setting up dev environments, infrastructure, VMs, software tools for coding, networks)
- Command line, terminal, Linux
- Git + GitHub
- Python
- SQL
- IaC Terraform
- Containerization (Docker)
- Cloud

de-zoomcamp linkedin posts + learnings
de-zoomcamp course solutions (all homework assignments 100%)
de-zoomcamp course leaderboard

- LLM Zoomcamp